package dev.shushant.resource.navigation

import androidx.compose.runtime.Composable
import androidx.compose.runtime.SideEffect
import androidx.compose.runtime.currentCompositeKeyHash
import androidx.compose.runtime.remember
import androidx.compose.runtime.saveable.SaveableStateHolder
import androidx.compose.runtime.saveable.rememberSaveableStateHolder
import androidx.compose.ui.layout.SubcomposeLayout

@Composable
internal fun <T> rememberSaveableScreenStateHolder(): SaveableScreenStateHolder<T> {
    val stateHolder = rememberSaveableStateHolder()
    return remember { SaveableScreenStateHolder(stateHolder) }
}

/**
 * Wrapper around a [SaveableStateHolder] that helps generate saveable (bundleable) keys for use
 * with the holder and removes keys after they're removed from the backstack.
 *
 * Because keys passed to [SaveableStateHolder.SaveableStateProvider] must be saveable (bundleable),
 * we can't just pass the backstack keys directly – they may not be bundleable. However, we ask
 * Compose to generate keys from the items using the [key] function. We can then derive an [Int] key
 * that will always be consistent for a given backstack keys, even across process restarts, and use
 * that for the saveable registry. This works as long as backstack keys implement hashcode
 * correctly, which they must to be supported by backstack anyway.
 */
internal class SaveableScreenStateHolder<T>(private val holder: SaveableStateHolder) {

    /**
     * Associates compose-generated "composite key hashes" with backstack items.
     */
    private val stateKeysByScreenKey = mutableMapOf<T, Int>()

    /**
     * Compose [content] for the (potentially non-bundleable) value [screenKey] so that any
     * `rememberSaveable`s in [content] will be saved and restored.
     *
     * Wraps [SaveableStateHolder.SaveableStateProvider].
     */
    @Composable
    fun SaveableStateProvider(screenKey: T, content: @Composable () -> Unit) {
        val stateKey = currentCompositeKeyHash

        // Once the composition has been committed, associate the item with the holder key generated
        // from the composition. This is so that when item is removed from the backstack,
        // removeStaleKeys knows which actual state key to remove from the holder.
        // This must be done in a SideEffect since keysByItem is not a snapshot state object.
        // The only synchronization requirement is that this key is added to the map before
        // removeStaleKeys is called after the item is removed from the backstack.
        SideEffect {
            val existingStateKey = stateKeysByScreenKey[screenKey]
            if (existingStateKey == null) {
                stateKeysByScreenKey[screenKey] = stateKey
            } else if (existingStateKey != stateKey) {
                error(
                    "Expected currentCompositeKeyHash to not change for Backstack items. " +
                            "Is the caller wrapped in a key() {}?"
                )
            }
        }

        // This function will automatically save and restore saveable state when it's skipped or
        // composed again. We have to use the compose-generated int stateKey, even though this function
        // accepts Any, because it doesn't _actually_ accept Any – it only accepts values that are
        // saveable, and the backstack item may not be saveable.
        holder.SaveableStateProvider(stateKey) {
            WorkaroundComposeStateBug(content)
        }
    }

    /**
     * Removes any keys that were generated by [SaveableStateProvider] but are not present in
     * [backstack] from the [SaveableStateHolder]
     *
     * Must only be called from a [SideEffect].
     */
    fun removeStaleKeys(backstack: List<T>) {
        stateKeysByScreenKey.iterator().apply {
            while (hasNext()) {
                val (screenKey, stateKey) = next()
                if (screenKey !in backstack) {
                    holder.removeState(stateKey)
                    remove()
                }
            }
        }
    }

    /**
     * TODO Remove this when the bug is fixed.
     * See https://issuetracker.google.com/issues/188567661#comment2.
     */
    @Composable
    private fun WorkaroundComposeStateBug(content: @Composable () -> Unit) {
        SubcomposeLayout { constraints ->
            val measurable = subcompose(Unit, content).single()
            val placeable = measurable.measure(constraints)
            layout(placeable.width, placeable.height) {
                placeable.placeRelative(0, 0)
            }
        }
    }
}